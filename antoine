NAME		=	minishell

CC			=	cc -Wall -Wextra -Werror -g3

SRCS		=	srcs/main.c\
				srcs/built-in/ft_echo.c\
				srcs/built-in/ft_env.c\
				srcs/built-in/ft_export.c\
				srcs/built-in/ft_export_utils.c\
				srcs/built-in/ft_export_utils_bis.c\
				srcs/built-in/ft_unset.c\
				srcs/built-in/ft_exit.c\
				srcs/built-in/ft_cd.c\
				srcs/clean_exit/clean.c\
				srcs/clean_exit/singletons.c\
				srcs/commands/cmds.c\
				srcs/commands/cmd_args.c\
				srcs/commands/lst_cmds.c\
				srcs/commands/lst_cmds_bis.c\
				srcs/commands/redir_cmds.c\
				srcs/debug/debug.c\
				srcs/env/get_env.c\
				srcs/env/lst_env.c\
				srcs/errors/error_handle.c\
				srcs/expand/expand.c\
				srcs/expand/expand_utils.c\
				srcs/expand/expand_utils_bis.c\
				srcs/built-in/ft_pwd.c\
				srcs/parsing-lexer/tokenization.c\
				srcs/parsing-lexer/lst_token.c\
				srcs/parsing-lexer/check_syntax.c\
				srcs/parsing-lexer/parsing_utils.c\
				srcs/parsing-lexer/parsing_utils_2.c\
				srcs/signals/signals.c\
				srcs/exec/get_path.c\
				srcs/exec/handle_access.c\
				srcs/exec/handle_errors.c\
				srcs/exec/handle_execve_error.c\
				srcs/exec/handle_duplications.c\
				srcs/exec/handle_path.c\
				srcs/exec/handle_processes.c\
				srcs/exec/handle_quotes_and_slash.c\
				srcs/exec/handle_spaces_and_slashes.c\
				srcs/exec/here_doc.c\
				srcs/exec/exec.c\
				srcs/exec/print_errors.c\
				srcs/exec/size_functions.c\
				srcs/exec/split.c\
				srcs/exec/string_functions.c\
				srcs/exec/wait_and_close.c\
				srcs/exec/handle_built_in.c\
				srcs/exec/handle_redir.c\
				includes/get_next_line/get_next_line.c\
				includes/get_next_line/get_next_line_utils.c\

OBJS		=	${SRCS:.c=.o}

LIBFT		=	includes/libft

FT_LIBFT	=	includes/libft/libft.a

PRINTF		=	includes/printf

FT_PRINTF	=	includes/printf/libftprintf.a


all:	${NAME} $(LIBFT) $(PRINTF)


$(NAME):	$(OBJS)
			make -C $(LIBFT) && make -C $(PRINTF) 
			$(CC) $(OBJS) -o $(NAME) $(FT_LIBFT) $(FT_PRINTF) -lreadline

clean:
			rm -f $(OBJS)
			make clean -C $(LIBFT) && make clean -C $(PRINTF) 

fclean:		clean
			rm -f ${NAME}
			make fclean -C $(LIBFT) && make fclean -C $(PRINTF)

re:			fclean
			make all

.PHONY:		all clean fclean re
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   handle_access.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: skiam <skiam@student.42.fr>                +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/02/08 14:46:15 by eltouma           #+#    #+#             */
/*   Updated: 2024/05/14 17:35:03 by eltouma          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/minishell.h"

void	ft_handle_rights(t_data *data, t_cmds *cmds, char *cmd, char *tmp2)
{
	if (tmp2)
		free (tmp2);
	ft_putstr_fd("minishell: ", 2);
	ft_free(data, cmds, cmd, "Permission denied\n");
	exit (ft_exit_code(126, ADD));
}

void	ft_handle_no_file_or_dir(t_data *data, t_cmds *cmds, char *cmd, char **args)
{
	(void)args;
	ft_putstr_fd("minishell: ", 2);
	ft_free(data, cmds, cmd, ": No such file or directory ðŸ˜®\n");
	exit (ft_exit_code(127, ADD));
}

void	ft_handle_directory(t_data *data, t_cmds *cmds, char *cmd, char **args)
{
	(void)args;
	ft_putstr_fd("minishell: ", 2);
	ft_free(data, cmds, cmd, "Is a directory\n");
	exit (ft_exit_code(126, ADD));
}
